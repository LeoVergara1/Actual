<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on Brandon Vergara </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://leovergara1.github.io/post/index.xml</link>
    <language>en-us</language>
    
    <copyright>Aprendiendo</copyright>
    <updated>Wed, 18 Jan 2017 13:38:40 CST</updated>
    
    <item>
      <title>Groovy Programming</title>
      <link>https://leovergara1.github.io/post/groovy/</link>
      <pubDate>Wed, 18 Jan 2017 13:38:40 CST</pubDate>
      
      <guid>https://leovergara1.github.io/post/groovy/</guid>
      <description>

&lt;p&gt;Primero que nada daré una breve descripción de lo que es groovy. Es un lenguaje ágil y dinámico para la máquina virtual de java, &lt;em&gt;“Construido sobre las fortalezas de Java pero tiene características adicionales de poder inspiradas por lenguajes como Python, Ruby y Smalltalk” (MakingDevs)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;La verdad es que jamás había escuchado sobre este lenguaje, y me doy cuenta que eso es realmente triste ya que cuenta con un gran potencial al ser un lenguaje dinamico y ademas cuenta con closures, builders y tipado dinámico.&lt;/p&gt;

&lt;p&gt;Realmente es increíble la simplificación que se logra hacer al lenguaje java, agilizando nuestros proyectos y dando un mejor entendimiento al problema para así realizar una óptima solución.&lt;/p&gt;

&lt;p&gt;Al principio estuve un poco desconcertado, por lo complejo que pudiera ser aprender este nuevo lenguaje, sin embargo con un poco de explicación entendí que prácticamente es lo mismo que java pero suprimiendo partes del código innecesario.&lt;/p&gt;

&lt;p&gt;Un claro ejemplo es el siguiente.&lt;/p&gt;

&lt;h2 id=&#34;hola-mundo-en-java&#34;&gt;Hola Mundo en JAVA&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public class HolaMundo {
  private String nombre;
  public String getNombre() {
    return nombre;
  }
  public void setNombre(String nombre) {
    this.nombre = nombre;
  }
  public String saluda() {
    return &amp;quot;Hola &amp;quot; + this.nombre + &amp;quot; !!!&amp;quot;;
  }
  public static void main(String[] args) {
    HolaMundo objeto = new HolaMundo();
    objeto.setNombre(&amp;quot;@grailsmx&amp;quot;);
    System.out.println(objeto.saluda());
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hola-mundo-en-groovy&#34;&gt;Hola Mundo en GROOVY&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;class HolaMundo {
  String nombre
  def saluda() { &amp;quot;Hola  ${this.nombre} !!!&amp;quot; }
}

def objeto = new HolaMundo(nombre:&amp;quot;@grailsmx&amp;quot;)
println(objeto.saluda())

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Realmente después de una series de pasos es impresionante la cantidad de código que nos logramos ahorrar con el uso de este lenguaje.&lt;/p&gt;

&lt;p&gt;Para finalizar es importante mencionar las siguientes características del lenguaje.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Admite el lenguaje tal cual de java dentro del código en caso de que no sepamos cómo escribirlo en groovy.&lt;/li&gt;
&lt;li&gt;Groovy es capaz de emigrar todo el proyecto al código de java junto consus “.class” necesarios para correr desde la consola.&lt;/li&gt;
&lt;li&gt;Con el uso de los cluseres dinámicos, definitivamente nuestra vida programando sera mas facil y obteniendo un nivel de programació con mejor nivel de tecnología.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Comandos en Unix y Linux</title>
      <link>https://leovergara1.github.io/post/Comandos/</link>
      <pubDate>Tue, 17 Jan 2017 09:38:42 CST</pubDate>
      
      <guid>https://leovergara1.github.io/post/Comandos/</guid>
      <description>

&lt;p&gt;De momento puede parecer que los comandos de Unix y Linux son iguales ya que convergen en términos de funcionalidad, el medio ambiente, facilidad de uso, así como las áreas en Unix y Linux son diferentes.&lt;/p&gt;

&lt;h1 id=&#34;un-poco-de-historia&#34;&gt;Un poco de historia…&lt;/h1&gt;

&lt;h3 id=&#34;unix&#34;&gt;Unix&lt;/h3&gt;

&lt;p&gt;La historia de UNIX  se remonta a 1969. A través de los años, se ha desarrollado y ha evolucionado a través de una serie de versiones distintas situaciones y entornos. Variantes de UNIX más modernos conocidos actualmente tienen licencia versiones de una de las ediciones originales de UNIX.&lt;/p&gt;

&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;

&lt;p&gt;Precisamente linux nació como una alternativa de software libre para los entornos Unix comerciales. Cuya historia inicia en 1983, cuando el proyecto GNU, donde el original tiene que ofrecer una alternativa libre a Unix, se introdujo. Linux se ejecuta en una gama mucho más amplia de plataformas que la mayoría de los entornos Unix, tales como la Intel  / AMD llevó plataforma x86. La mayoría de las variantes de Unix ejecutan en una sola arquitectura.&lt;/p&gt;

&lt;h1 id=&#34;tipo-de-shell&#34;&gt;Tipo de Shell&lt;/h1&gt;

&lt;p&gt;Shell Bourne (sh). Creado por S. Bourne, es el más utilizado en la actualidad. Su símbolo del sistema es $. Es el shell estándar y el que se monta en casi todos los sistemas UNIX/Linux.
Es un software que forma parte del sistema operativo, sirve para interpretar órdenes expresadas por líneas de comandos.
En Unix es conocido como bash y en linux como ksh&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;IMG src=&#34;https://leovergara1.github.io/images/unixS.jpg&#34;/&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;diferencias-entre-estas-dos-shell&#34;&gt;Diferencias entre estas dos shell&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ksh soporta arreglos asociativos&lt;/li&gt;
&lt;li&gt;ksh permite acceder el valor de una variable usada en un loop fuera del mismo&lt;/li&gt;
&lt;li&gt;bash maneja los códigos de salida &amp;ldquo;exit&amp;rdquo; a través de tuberías (pipes) de una manera mas clara.&lt;/li&gt;
&lt;li&gt;ksh soporta el comando &amp;ldquo;print&amp;rdquo; el cual es más completo que el comando &amp;ldquo;echo&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;bash soporta completar nombres de archivos y comandos usando la tecla &amp;ldquo;tab&amp;rdquo;&lt;/li&gt;
&lt;li&gt;ksh soporta una sintaxis del comando &amp;ldquo;cd&amp;rdquo; que permite moverse entre directorios de una manera más eficiente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://leovergara1.github.io/images/comandos.png&#34; alt=&#34;Comnados&#34; /&gt;&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inicio en goHugo</title>
      <link>https://leovergara1.github.io/post/Inicio-en-goHugo/</link>
      <pubDate>Thu, 12 Jan 2017 15:07:41 CST</pubDate>
      
      <guid>https://leovergara1.github.io/post/Inicio-en-goHugo/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://leovergara1.github.io/images/hugo1.png&#34; alt=&#34;Hugo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Prácticamente es un framework que sirve para realizar sitios estáticos.  A diferencia de otros sistemas que construyen dinámicamente una página cada vez que un visitante solicita una. Dado que los sitios web son vistos con mucha más frecuencia de lo que se editan, Hugo está optimizado para la visualización de página web al tiempo que proporciona una gran experiencia de la escritura.&lt;/p&gt;

&lt;p&gt;Primero que nada visite la siguiente página para realizar la instalación y de igual manera familiarizarme con el framework ya que en ella se encuentra un pequeño tutorial de inicio rápido.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://leovergara1.github.io/images/hugo2_opt.jpg&#34; alt=&#34;Hugo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;De la siguiente manera seguí los pasos correspondientes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Crear el proyecto en hugo con el siguiente comando &lt;strong&gt;$hugo new site BlogLeo&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Despues Agregar un pos de la siguiente manera &lt;strong&gt;$hugo new post/primero.md&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;En este apartado debo comentar que en momentos tenía problemas a la hora de crear los post, ya que siempre se debe estar en la carpeta raíz del proyecto.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;3.Agregar un tema al proyecto para después ser publicado, esté se debe guardar en la carpeta “themes” o de lo contrario no funcionara.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Aquí fue un de los momentos donde tuve mayores problema ya que a la hora de tratar de llamar al tema había que hacer ciertas configuración en el config.tom para que funcionara.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;4.Finalmente se nos menciona como levantar un servidor local para visualizar nuestro sitio en la aplicación del navegador&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://leovergara1.github.io/images/captura1.png&#34; alt=&#34;Captura&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En lo personal, pienso que al principio fue complicado de entender, principalmente la parte de los temas ya que si me tomo mucho tiempo lograr configurarlos a mi gusto, pero ya una vez hecho esto logre, hacer uso de ciertas herramientas de manera más sencilla.&lt;/p&gt;

&lt;p&gt;Otro problema con el que me encontré fue con el de subir el sitio ya de manera pública, ya que tuve muchos problemas con las configuraciones para lograr hacer este proceso.&lt;/p&gt;

&lt;p&gt;primero que nada tuve que realizar un proyecto con control de versiones mediante Git para así dejar una versión funcionando de manera local y en otra rama realizar las modificaciones correspondientes para subir el sitio a la red. Los problemas que encontré fueron:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Cargar el tema&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cargar imágenes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modificar los vínculos de los post que el tema tenía predeterminados&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Usar un tema correspondiente a la versión de hugo instalada&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conceptos básicos de Git para la conexión remota&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;En esta parte mi problema fue que confundí el origen del repositorio lo que no me permitia hacer un “git push” de manera correcta, posteriormente después de unos ejemplos con mis compañeros esto quedó de manera más clara así como las 3 formas de hacer el acceso remoto.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Clonar el repositorio y bajarlo a la pc&lt;/li&gt;
&lt;li&gt;Subir al repositorio una carpeta ya creada&lt;/li&gt;
&lt;li&gt;Crear un repositorio nuevo&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Problemas con temas de goHugo</title>
      <link>https://leovergara1.github.io/post/Cuearto-post/</link>
      <pubDate>Thu, 12 Jan 2017 09:37:34 CST</pubDate>
      
      <guid>https://leovergara1.github.io/post/Cuearto-post/</guid>
      <description>&lt;p&gt;Problemas con temas de hugo&lt;/p&gt;

&lt;p&gt;Al iniciar mi viaje con el framework hugo,  no tuve problemas para crear el sitio con sus carpetas predeterminadas y con sus correspondientes post, pero a la hora de levantar el servidor para ver un ejemplo de lo que estaba creando, levantaba correctamente pero sin cargar el tema.&lt;/p&gt;

&lt;p&gt;El comando ejecutado era el siguiente:
$ hugo server &amp;ndash;theme=”hurock” &amp;ndash;buildDrafs
Dicho problema ocasiona que los elementos no se mostrarán  correctamente o simplemente no se veían. La verdad fue que este inconveniente me demoro un par de horas y el problema solo radicaba en la configuración del archivo config.toml en la línea correspondiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. basurl = &amp;quot;https://localhost:1313/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bastaba con arreglar un simple detalle, el cual era el siguiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. https: -&amp;gt; http: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Así es solo quitamos la letra “s” y el problema se habrá solucionado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inicio en Makings Devs</title>
      <link>https://leovergara1.github.io/post/Primer-post/</link>
      <pubDate>Wed, 11 Jan 2017 16:08:27 CST</pubDate>
      
      <guid>https://leovergara1.github.io/post/Primer-post/</guid>
      <description>&lt;p&gt;En el día de mi entrevista pude darme cuenta, estaba entrando a un gran reto ya que aquí se tiene la ideología diciendo que se debe tener una buena base teórica de los conceptos  para llevar a cabo un correcto desempeño en el desarrollo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://leovergara1.github.io/images/teoria.png&#34; alt=&#34;Teoria&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En primeros días en making devs, me logre dar cuenta que existían varias tecnología de las cuales apenas había escuchado y de otras no tenía ni la menor idea como son:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        1. Git
        2. GitHub
        3. CoffeeScript
        4. Grails
        5. GoHugo
        6. Vertx
        7. Groovy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo el concepto que más claro me quedó fue el de &lt;strong&gt;Integración continua&lt;/strong&gt; el cual nos garantiza que las pruebas de una aplicación serán estables, dicho concepto se refiere a lo siguientes puntos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Conjunción de sistemas -&amp;gt; Control de versiones como Git&lt;/li&gt;
&lt;li&gt;Trigger de ejecución -&amp;gt;&lt;/li&gt;
&lt;li&gt;Componente de ejecución -&amp;gt; jenkins&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Después de investigar una serie de conceptos y teorías que me hacían falta reforzar para un conocimiento básico de las herramientas que en un futuro utilizaré, realice el siguiente documento como guía de estudio.&lt;/p&gt;

&lt;iframe width=&#34;600px&#34; height=&#34;600px&#34; src=&#34;https://drive.google.com/open?id=1cnFEzMq8ghtzGYwAAsyEa-O6OOZbdzgKQUw9TMZ7ps4&#34;&gt;
  &lt;p&gt;Your browser does not support iframes.&lt;/p&gt;
&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;https://drive.google.com/open?id=1cnFEzMq8ghtzGYwAAsyEa-O6OOZbdzgKQUw9TMZ7ps4&#34;&gt;&lt;img src=&#34;https://leovergara1.github.io/images/doc.png&#34; alt=&#34;doc Logo&#34; /&gt;&lt;/a&gt; &lt;strong&gt;Dar clic en la imagen para ver documento&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;En el documento se tratan conceptos en general desde que es orientación a objetos hasta tipos de shell o diferencias entre unix y linux y sus origines a grandes rasgos.&lt;/p&gt;

&lt;p&gt;Personalmente esta tarea de iniciación me hizo darme cuenta de los elementos básicos que me hacían falta y que jamás debo de despreciar la teoría ya que es importante para el correcto entendimiento de las herramientas.
Siempre he sido una persona que confía en sus habilidades y que se cree capaz, aún cuando la entrevista me hizo ver que me faltaba un largo camino que recorrer, no me desanimo al contrario mes gusta verlo como un reto y me motiva saber lo mucho que tengo que aprender para tener como primer fin lograr contribuir a mi equipo de trabajo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
